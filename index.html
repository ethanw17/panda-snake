<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Panda Snake - Canvas</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --accent: #22c55e; /* green-500 */
      --accent-2: #86efac; /* green-300 */
      --text: #e5e7eb; /* gray-200 */
      --muted: #9ca3af; /* gray-400 */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 80% -20%, #1f2937, var(--bg));
      color: var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    .wrap {
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 14px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    h1 {
      font-size: 1.25rem;
      margin: 0;
      letter-spacing: 0.3px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      background: var(--panel);
      color: var(--text);
      border: 1px solid #1f2937;
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
    }
    button:hover { background: #0b1220; }
    button:active { transform: translateY(1px); }
    .pill { border-color: #334155; }

    .hud {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
      font-weight: 600;
      color: var(--accent-2);
    }
    .board-wrap {
      background: #0b1220;
      border: 1px solid #1f2937;
      border-radius: 16px;
      padding: 8px;
      display: grid;
      justify-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    canvas { 
      background: repeating-linear-gradient(45deg, #0f172a, #0f172a 12px, #0c1220 12px, #0c1220 24px);
      border-radius: 12px;
      touch-action: none; /* allow custom gestures */
    }

    /* Mobile dpad */
    .dpad {
      display: grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      gap: 6px;
      justify-content: center;
      margin: 10px 0 0;
      user-select: none;
    }
    .dpad button { width: 64px; height: 64px; font-size: 18px; }
    .dpad .empty { visibility: hidden; }
    .badge { font-size: 0.9rem; color: var(--muted); }
    .muted { color: var(--muted); font-weight: 500; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üêº Panda Snake</h1>
      <div class="controls">
        <button id="startBtn" class="pill">Start</button>
        <button id="pauseBtn" class="pill">Pause</button>
        <button id="resetBtn" class="pill">Reset</button>
        <span class="badge">Use arrows, WASD, swipe, or the dpad</span>
      </div>
    </header>

    <div class="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Best: <span id="best">0</span></div>
      <div class="muted">Speed: <span id="speed">1x</span></div>
    </div>

    <div class="board-wrap">
      <canvas id="game" width="512" height="512"></canvas>
      <div class="dpad" id="dpad">
        <span class="empty"></span>
        <button data-dir="up">‚ñ≤</button>
        <span class="empty"></span>
        <button data-dir="left">‚óÄ</button>
        <span class="empty"></span>
        <button data-dir="right">‚ñ∂</button>
        <span class="empty"></span>
        <button data-dir="down">‚ñº</button>
        <span class="empty"></span>
      </div>
    </div>

    <p class="muted">Eat üéç bamboo to grow. Do not bonk the wall or your own fluffy tail.</p>
  </div>

  <script>
    (() => {
      'use strict';
      // Canvas and context
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI elements
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const resetBtn = document.getElementById('resetBtn');
      const scoreEl = document.getElementById('score');
      const bestEl = document.getElementById('best');
      const speedEl = document.getElementById('speed');
      const dpad = document.getElementById('dpad');

      // Grid settings
      const CELL = 24; // pixels per cell
      const COLS = Math.floor(canvas.width / CELL);
      const ROWS = Math.floor(canvas.height / CELL);

      // Game state
      let snake, dir, nextDir, bamboo, score, best, running, lastStep, stepInterval, speedLevel;

      // Load best score
      best = Number(localStorage.getItem('panda_best') || 0);
      bestEl.textContent = best;

      // Audio context for cute boops and sad tune
      let audioCtx = null;
      function getAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      }

      function playBoop() {
        // Short cute boop using a sine blip with quick envelope
        const ac = getAudio();
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(880, ac.currentTime);
        o.frequency.exponentialRampToValueAtTime(1200, ac.currentTime + 0.05);
        g.gain.setValueAtTime(0.0001, ac.currentTime);
        g.gain.exponentialRampToValueAtTime(0.3, ac.currentTime + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.12);
        o.connect(g).connect(ac.destination);
        o.start();
        o.stop(ac.currentTime + 0.15);
      }

      async function playSadSong() {
        const ac = getAudio();
        const notes = [
          { f: 392, d: 0.18 }, // G4
          { f: 370, d: 0.18 }, // F#4
          { f: 349, d: 0.18 }, // F4
          { f: 330, d: 0.24 }, // E4
          { f: 294, d: 0.3 },  // D4
          { f: 262, d: 0.36 }, // C4
        ];
        let t = ac.currentTime;
        for (const n of notes) {
          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = 'triangle';
          o.frequency.setValueAtTime(n.f, t);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.exponentialRampToValueAtTime(0.24, t + 0.03);
          g.gain.exponentialRampToValueAtTime(0.0001, t + n.d);
          const dn = ac.createBiquadFilter();
          dn.type = 'lowpass';
          dn.frequency.setValueAtTime(1200, t);
          o.connect(dn).connect(g).connect(ac.destination);
          o.start(t);
          o.stop(t + n.d + 0.02);
          t += n.d * 0.9; // slight overlap
        }
      }

      function randCell() {
        return {
          x: Math.floor(Math.random() * COLS),
          y: Math.floor(Math.random() * ROWS)
        };
      }

      function init() {
        snake = [ { x: Math.floor(COLS/2), y: Math.floor(ROWS/2) } ];
        dir = { x: 1, y: 0 };
        nextDir = { x: 1, y: 0 };
        bamboo = placeBamboo();
        score = 0;
        scoreEl.textContent = score;
        running = false;
        lastStep = 0;
        speedLevel = 1; // increases every 5 bamboo
        stepInterval = 140; // ms per step
        updateSpeedLabel();
        draw();
      }

      function updateSpeedLabel() {
        speedEl.textContent = speedLevel + 'x';
      }

      function placeBamboo() {
        let cell;
        do { cell = randCell(); } while (snake.some(s => s.x === cell.x && s.y === cell.y));
        return cell;
      }

      function setDirection(nx, ny) {
        // Prevent reversing into itself
        if (nx === -dir.x && ny === -dir.y) return;
        nextDir = { x: nx, y: ny };
      }

      function gameOver() {
        running = false;
        playSadSong();
        // Flash effect
        canvas.style.filter = 'grayscale(1) brightness(1.2)';
        setTimeout(() => canvas.style.filter = '', 300);
      }

      function step(ts) {
        if (!running) return;
        if (!lastStep) lastStep = ts;
        const elapsed = ts - lastStep;
        if (elapsed >= stepInterval) {
          lastStep = ts;
          dir = nextDir;
          const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

          // Wall collision
          if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
            gameOver();
            draw();
            return;
          }
          // Self collision
          if (snake.some((s, i) => i !== 0 && s.x === head.x && s.y === head.y)) {
            gameOver();
            draw();
            return;
          }

          snake.unshift(head);

          // Eat bamboo
          if (head.x === bamboo.x && head.y === bamboo.y) {
            score++;
            scoreEl.textContent = score;
            if (score > best) {
              best = score;
              localStorage.setItem('panda_best', best);
              bestEl.textContent = best;
            }
            playBoop();
            bamboo = placeBamboo();

            if (score % 5 === 0 && stepInterval > 70) {
              stepInterval -= 10;
              speedLevel++;
              updateSpeedLabel();
            }
          } else {
            snake.pop();
          }

          draw();
        }
        requestAnimationFrame(step);
      }

      function drawGrid() {
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        for (let x = 0; x <= COLS; x++) {
          ctx.beginPath();
          ctx.moveTo(x * CELL + 0.5, 0);
          ctx.lineTo(x * CELL + 0.5, canvas.height);
          ctx.stroke();
        }
        for (let y = 0; y <= ROWS; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * CELL + 0.5);
          ctx.lineTo(canvas.width, y * CELL + 0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawPandaCell(x, y, index) {
        // Draw a simple panda face per segment using emoji for charm
        const px = x * CELL + CELL / 2;
        const py = y * CELL + CELL / 2 + 2;
        ctx.font = `${Math.floor(CELL * 0.9)}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const char = 'üêº';
        ctx.fillText(char, px, py);
        // Add a tiny shadow to the head segment
        if (index === 0) {
          ctx.save();
          ctx.globalAlpha = 0.2;
          ctx.beginPath();
          ctx.arc(px, py + 8, CELL * 0.35, 0, Math.PI * 2);
          ctx.fillStyle = '#000';
          ctx.fill();
          ctx.restore();
        }
      }

      function drawBamboo(x, y) {
        const gx = x * CELL;
        const gy = y * CELL;
        const pad = 6;
        const w = CELL - pad * 2;
        const h = CELL - pad * 2;
        ctx.save();
        // stalk
        ctx.fillStyle = '#16a34a';
        ctx.fillRect(gx + pad + w * 0.35, gy + pad, w * 0.3, h);
        // nodes
        ctx.fillStyle = '#22c55e';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(gx + pad + w * 0.32, gy + pad + i * (h / 3) - 2, w * 0.36, 4);
        }
        // leaves
        ctx.fillStyle = '#4ade80';
        ctx.beginPath();
        ctx.ellipse(gx + pad + w * 0.2, gy + pad + h * 0.25, 6, 12, Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(gx + pad + w * 0.8, gy + pad + h * 0.65, 6, 12, -Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // subtle vignette
        const g = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 40, canvas.width/2, canvas.height/2, canvas.width/1.2);
        g.addColorStop(0, 'rgba(255,255,255,0.02)');
        g.addColorStop(1, 'rgba(0,0,0,0.15)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawGrid();
        // Bamboo
        drawBamboo(bamboo.x, bamboo.y);
        // Snake as pandas
        snake.forEach((seg, i) => drawPandaCell(seg.x, seg.y, i));

        if (!running) {
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = '#e5e7eb';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = '700 28px Inter, system-ui, sans-serif';
          ctx.fillText('Tap Start to play', canvas.width/2, canvas.height/2 - 12);
          ctx.font = '500 16px Inter, system-ui, sans-serif';
          ctx.fillText('Arrows, WASD, swipe, or dpad', canvas.width/2, canvas.height/2 + 16);
          ctx.restore();
        }
      }

      // Resize for small screens while keeping grid alignment
      function fitCanvas() {
        const maxSize = Math.min(window.innerWidth - 32, 512);
        const size = Math.max(288, Math.min(512, Math.round(maxSize / CELL) * CELL));
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
      }
      window.addEventListener('resize', fitCanvas);
      fitCanvas();

      // Input handlers
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'arrowup' || k === 'w') setDirection(0, -1);
        else if (k === 'arrowdown' || k === 's') setDirection(0, 1);
        else if (k === 'arrowleft' || k === 'a') setDirection(-1, 0);
        else if (k === 'arrowright' || k === 'd') setDirection(1, 0);
        else if (k === ' ') running ? pause() : start();
      });

      // Touch controls: swipe detection
      let touchStart = null;
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length) touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }, { passive: true });
      canvas.addEventListener('touchend', (e) => {
        if (!touchStart) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStart.x;
        const dy = t.clientY - touchStart.y;
        const ax = Math.abs(dx), ay = Math.abs(dy);
        if (Math.max(ax, ay) > 16) {
          if (ax > ay) setDirection(Math.sign(dx), 0);
          else setDirection(0, Math.sign(dy));
        }
        touchStart = null;
      });

      // Dpad buttons
      dpad.addEventListener('click', (e) => {
        const b = e.target.closest('button');
        if (!b) return;
        const m = b.getAttribute('data-dir');
        if (m === 'up') setDirection(0, -1);
        if (m === 'down') setDirection(0, 1);
        if (m === 'left') setDirection(-1, 0);
        if (m === 'right') setDirection(1, 0);
      });

      function start() {
        if (running) return;
        running = true;
        lastStep = 0;
        requestAnimationFrame(step);
      }
      function pause() { running = false; }

      startBtn.addEventListener('click', start);
      pauseBtn.addEventListener('click', pause);
      resetBtn.addEventListener('click', () => { init(); });

      // Initialize and draw once
      init();
    })();
  </script>
</body>
</html>
